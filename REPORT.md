
# Отчёт по лабораторной работе: разработка расширения для VS Code

## 1. Постановка задачи и техническое задание

Цель работы — разработать расширение для среды разработки Visual Studio Code,
которое автоматизирует приведение C/C++‑кода к стилю, близкому к
Google C++ Style Guide, с учётом следующих требований:

### Функциональные требования

1. Расширение должно предоставлять **две команды**:
   - команда для обработки **всего рабочего пространства** (workspace),
   - команда для обработки **только текущего файла**, открытого в редакторе.
2. При обработке файлов расширение должно:
   - запускать `clang-tidy` с автоматическим применением правок (`-fix`),
   - запускать `clang-format` для автоформатирования кода.
3. Команда для рабочего пространства:
   - должна **не изменять нейминг идентификаторов** (имена функций, переменных,
     констант и т.д.),
   - должна применять только безопасные правки стиля, задаваемые конфигурацией
     `.clang-tidy` (кроме `readability-identifier-naming`) и `.clang-format`.
4. Команда для текущего файла:
   - должна анализировать диагностические сообщения `clang-tidy` по правилу
     `readability-identifier-naming`,
   - на основе этих диагностик должна вычислять корректные имена в соответствии
     с соглашениями именования (PascalCase, kPascalCase, lower_snake_case),
   - должна переименовывать идентификаторы через механизм **Rename Symbol** в VS Code,
     чтобы корректно обновлялись все вхождения в проект,
   - после переименований должна запускать `clang-tidy -fix` (с отключённым
     `readability-identifier-naming`) и `clang-format` для окончательной
     правки стиля.
5. Расширение должно работать **однократно по команде пользователя**.
   Оно не должно запускать автоформатирование в фоне и не должно изменять код
   без явного вызова соответствующей команды.

### Нефункциональные требования

1. Расширение должно быть кроссплатформенным и работать на Windows, Linux и macOS
   при наличии установленных `clang-tidy` и `clang-format`.
2. Настройки путей к инструментам и параметров обработки должны быть выведены
   в конфигурацию расширения (`settings.json` в VS Code).
3. Табуляция в коде должна соответствовать требованиям заданного `.clang-format`,
   в частности — использовать видимую ширину 4 пробела.
4. Исходный код расширения должен быть размещён в открытом репозитории
   (GitHub) с README‑файлом и отдельной документацией.
5. Код должен быть прокомментирован, архитектура — описана в отчёте.

---

## 2. Архитектура VS Code в разрезе разработки расширений

Visual Studio Code имеет модульную архитектуру, в которой дополнительный
функционал реализуется в виде **расширений** (extensions).

Ключевые компоненты, с которыми взаимодействует разработчик плагина:

1. **Extension Host (процесс расширений)**  
   Отдельный процесс, в котором исполняется код расширений на Node.js.  
   Расширение подключается к VS Code через API из модуля `vscode`.

2. **Манифест расширения (`package.json`)**  
   Описывает:
   - метаданные (название, версия, автор),
   - минимальную версию VS Code,
   - точки расширения (**contributes**): команды, настройки, языковые функции,
   - события активации (**activationEvents**):
     - `onCommand:...` — активация при вызове определённой команды,
     - или другие (открытие файла, тип языка и т.д.).

3. **Активатор и точка входа (`extension.ts` / `extension.js`)**  
   Основной модуль, который экспортирует две функции:
   - `activate(context: vscode.ExtensionContext)` — вызывается при первой
     активации расширения, здесь регистрируются команды, слушатели и т.д.,
   - `deactivate()` — вызывается при выгрузке расширения (обычно пустая).

4. **API команд и редактора**  
   Через `vscode.commands.registerCommand` расширение регистрирует новые команды,
   которые могут вызываться:
   - из Command Palette,
   - из меню,
   - через keybinding.
   Через объекты `vscode.window`, `vscode.workspace` и др. расширение может:
   - работать с активным редактором и файлами,
   - читать/записывать документы,
   - получать настройки пользователя,
   - отображать сообщения, прогресс и т.д.

5. **Взаимодействие с внешними утилитами**  
   Из Node.js‑части расширения можно запускать внешние процессы (например,
   `clang-tidy`, `clang-format`) через стандартный модуль `child_process`.
   Таким образом, VS Code расширение выступает как “обвязка” для существующих
   инструментов анализа и форматирования кода.

В данной работе используется именно этот сценарий:
манифест описывает команды и настройки, точка входа реализует их логику,
а тяжёлая работа по анализу/форматированию делегируется внешним утилитам
(`clang-tidy`, `clang-format`, язык-сервер C/C++).

---

## 3. Архитектура разработанного плагина

### 3.1. Общая структура проекта

Репозиторий содержит основные файлы:

- `package.json` — манифест расширения:
  - метаданные (`name`, `displayName`, `version`, `publisher`),
  - ссылки на репозиторий и домашнюю страницу (GitHub),
  - описание точек расширения (`contributes.commands`, `contributes.configuration`),
  - настройка сборки (`scripts`, `devDependencies`),
  - указание основного модуля: `"main": "./out/extension.js"`.
- `src/extension.ts` — исходный код логики расширения (TypeScript).
- `out/extension.js` — скомпилированный JavaScript (генерируется `tsc`).
- `.clang-format` — конфигурация форматирования C/C++ кода.
- `.clang-tidy` — конфигурация статического анализа и стиля.
- `README.md` — подробная документация для пользователя расширения.
- Дополнительные служебные файлы (`tsconfig.json`, файлы сборки и т.д.).

### 3.2. Основные компоненты `extension.ts`

1. **Логирование и запуск внешних утилит**

   - `outputChannel = vscode.window.createOutputChannel('Google C++ Style Fixer')`  
     Отдельный вывод для сообщений расширения.
   - Функция `runTool(cmd, args, cwd): Promise<ExecResult>`:
     - запускает внешний процесс `clang-tidy` или `clang-format` через
       `child_process.spawn`,
     - накапливает `stdout` и `stderr`,
     - логирует команду, вывод и код возврата в `outputChannel`,
     - возвращает структуру с кодом завершения и выводом.

2. **Константа конфигурации для отключения именования в режиме fix**

   - `NAMING_CONFIG_OVERRIDE = "{Checks: '-readability-identifier-naming', InheritParentConfig: true}";`  
     Используется для запуска `clang-tidy -fix`, чтобы:
     - взять существующую `.clang-tidy` конфигурацию,
     - поверх неё локально отключить **только**
       `readability-identifier-naming` (во избежание автоматических переименований).

3. **Сбор файлов для обработки**

   - `collectCppFiles(folder, fileGlobs, excludeGlobs): Promise<vscode.Uri[]>`  
     Использует `vscode.workspace.findFiles` с шаблонами включения и исключения.
     Фильтрует файлы, чтобы они лежали внутри конкретной папки рабочего пространства.

4. **Обработка множества файлов (workspace‑команда)**

   - `fixFilesGoogleStyle(files, folders, title)`:
     - для каждого файла:
       - определяет рабочий каталог (`cwd`) в рамках соответствующей папки,
       - запускает `clang-tidy -fix -fix-errors`, добавляя опционально `-p=buildDir`
         и `-config={...NAMING_CONFIG_OVERRIDE...}`,
       - затем запускает `clang-format -i`,
     - показывает прогресс через `vscode.window.withProgress`,
     - сообщает о завершении операции.

   - `fixWorkspaceGoogleStyle()`:
     - читает `googleStyleFixer.fileGlobs` и `googleStyleFixer.excludeGlobs` из настроек,
     - для всех открытых папок workspace собирает C/C++ файлы,
     - передаёт их в `fixFilesGoogleStyle(...)`.

5. **Модуль работы с неймингом для текущего файла**

   - Тип `NamingDiag` и функции:
     - `toLowerSnake`, `toPascalCase`, `toLowerCamelFromSnake` — утилиты конвертации
       стиля имен.
     - `inferTargetName(kind, current)` — вычисляет целевое имя в зависимости от
       типа сущности:
       - функции/методы → PascalCase,
       - константы → kPascalCase,
       - переменные/параметры/члены/namespace → lower_snake_case.
     - `parseNamingDiagnostics(tidyOutput)` — разбирает текстовый вывод `clang-tidy`
       по шаблону варнингов `readability-identifier-naming` и извлекает:
       файл, строку, столбец, тип сущности и её имя.
     - `runTidyNoFixOnFile(file, cwd, clangTidyPath, buildDir)` — запускает
       `clang-tidy` без `-fix`, без `-config` override, чтобы получить “чистую”
       диагностику в соответствии с `.clang-tidy`.

6. **Обработка текущего файла (current‑file‑команда)**

   - `fixCurrentFileGoogleStyle()` выполняет:
     1. Проверка наличия активного редактора и workspace‑папки.
     2. Чтение настроек `clangTidyPath`, `clangFormatPath`, `buildDir`.
     3. Сохранение документа.
     4. Запуск `runTidyNoFixOnFile(...)`, парсинг диагностик именования.
     5. Для каждой диагностики (снизу вверх, чтобы не сломать позиции):
        - открытие актуального документа,
        - вычисление позиции и диапазона идентификатора,
        - получение текущего текста,
        - вычисление `target = inferTargetName(...)`,
        - вызов `vscode.executeDocumentRenameProvider` с этим новым именем,
        - применение полученного `WorkspaceEdit` и сохранение файла.
     6. Запуск `clang-tidy -fix` с включённым `NAMING_CONFIG_OVERRIDE` (то есть
        без `readability-identifier-naming`).
     7. Запуск `clang-format -i` и повторное сохранение документа.
     8. Вывод сообщения об успешном завершении.

7. **Регистрация команд и активация расширения**

   - `activate(context: vscode.ExtensionContext)`:
     - регистрирует команду `googleStyleFixer.fixWorkspace` → `fixWorkspaceGoogleStyle()`,
     - регистрирует команду `googleStyleFixer.fixAndRenameCurrentFile` → `fixCurrentFileGoogleStyle()`,
     - сохраняет регистрации в `context.subscriptions`.
   - `deactivate()` — пустая, специальной логики при выгрузке не требуется.

Диаграмма (словесно):
- Пользователь вызывает команду из VS Code → API команд VS Code →
  код `extension.ts` → запуск `clang-tidy` / `clang-format` →
  изменение файлов → обновление редактора → сообщения в `Output` и `Notification`.

---

## 4. Описание реализованного функционала плагина

### 4.1. Команды

1. **Fix C++ Google Style in Workspace without hard renaming**  
   (ID: `googleStyleFixer.fixWorkspace`)

   - Обрабатывает все C/C++ файлы в workspace согласно шаблонам из настроек.
   - Для каждого файла запускает `clang-tidy -fix -fix-errors` с временной
     конфигурацией, отключающей только `readability-identifier-naming`.
   - Затем запускает `clang-format -i`.
   - Никаких переименований идентификаторов не выполняется: нейминг контролируется
     пользователем через явные действия и отдельную команду.

2. **Fix C++ Google Style in Current File**  
   (ID: `googleStyleFixer.fixAndRenameCurrentFile`)

   - Обрабатывает только активный файл.
   - Сначала собирает naming‑диагностику `clang-tidy` и по каждой проблеме
     вызывает встроенный механизм Rename Symbol для безопасного переименования
     по всему проекту.
   - После завершения переименований запускает `clang-tidy -fix` (без чека
     именования) и `clang-format -i` для остальных правок стиля.

### 4.2. Настройки расширения

Через `contributes.configuration` объявлены параметры:

- `googleStyleFixer.clangTidyPath` — путь к `clang-tidy`.
- `googleStyleFixer.clangFormatPath` — путь к `clang-format`.
- `googleStyleFixer.buildDir` — директория с `compile_commands.json` (например `"build"`).
- `googleStyleFixer.fileGlobs` — массив glob‑шаблонов для поиска файлов.
- `googleStyleFixer.excludeGlobs` — массив glob‑шаблонов для исключения файлов.
- `googleStyleFixer.gitDiffBase` — зарезервировано под возможный режим работы
  только с изменёнными файлами (на данный момент в коде не используется).

### 4.3. Использование внешних конфигураций

- `.clang-format` — задаёт правила форматирования:
  - основание на Google стиле,
  - ширина табуляции и отступа 4,
  - обязательные фигурные скобки для коротких `if`/`for`/`while`,
  - ограничение длины строки, стиль размещения скобок и т.д.
- `.clang-tidy` — задаёт набор включённых проверок и их параметры:
  - `google-*`, `bugprone-*`, `modernize-*`, `performance-*` и др.,
  - `readability-braces-around-statements` с параметрами для добавления скобок,
  - `readability-identifier-naming` с детальной настройкой кейсов и префиксов.

Расширение не дублирует эти правила внутри кода, а использует внешние файлы
как “источник правды”. Благодаря этому пользователь может тонко настраивать
стиль без изменений в самом плагине.

---

## 5. Документация и репозиторий

Исходный код расширения размещён в публичном репозитории GitHub:

- **URL репозитория:**  
  `https://github.com/shachenkovakate/VSCode-extension`

В репозитории присутствуют:

1. **README.md** — пользовательская документация на английском языке, включающая:
   - описание назначения расширения,
   - системные требования и шаги установки (через VSIX и из исходников),
   - подробное описание обеих команд,
   - настройку путей к инструментам и glob‑шаблонов,
   - пример конфигурации `.clang-format`,
   - пример конфигурации `.clang-tidy`,
   - раздел по устранению неполадок.
2. **Комментарии в исходном коде `extension.ts`** — поясняют ключевые участки
   логики (назначение функций, шаги обработки и т.п.).
3. Дополнительные конфигурационные файлы (`.clang-format`, `.clang-tidy`),
   служащие одновременно и как часть документации по стилю проекта.

При необходимости документация может быть автоматически сгенерирована на основе
комментариев к коду с использованием стандартных средств TypeScript/JS‑экосистемы,
но для данной лабораторной работы достаточно существующих Markdown‑файлов.

---

## 6. Рекомендации по демонстрации работы плагина

Для демонстрации на защите лабораторной работы удобно показать следующие сценарии:

1. **Демонстрация workspace‑команды**:
   - Открыть C/C++ проект со стилевыми нарушениями:
     - одинарные `if`/`for` без фигурных скобок,
     - смешанный стиль отступов,
     - длинные строки и т.д.
   - Запустить команду
     **“Fix C++ Google Style in Workspace without hard renaming”**.
   - Показать, что:
     - фигурные скобки добавились согласно правилам,
     - форматирование выровнялось (отступы, табы, переносы строк),
     - имена функций/переменных не изменились.

2. **Демонстрация current‑file‑команды с неймингом**:
   - Открыть файл, где явно нарушен стиль именования,
     например: `void popcount(Int2025 val);`, глобальные константы без `k` и т.д.
   - Запустить команду **“Fix C++ Google Style in Current File”**.
   - Показать, что:
     - функция `popcount` переименовалась в `Popcount`,
       всё использование в файле/проекте обновилось,
     - константы и переменные привели свой стиль к заданным правилам,
     - после этого код дополнительно отформатирован (`clang-tidy -fix` + `clang-format`).

3. **Показ логов в Output**:
   - Открыть вкладку **“Google C++ Style Fixer”** в Output и показать,
     что там логируются:
     - запускаемые команды,
     - пути к файлам и каталогам,
     - коды возврата и вывод утилит.

---

## 7. Заключение

В ходе выполнения лабораторной работы был разработан плагин для Visual Studio Code,
решающий практическую задачу приведения C/C++‑кода к стилю, близкому к Google
C++ Style Guide, с учётом пользовательских настроек и конфигураций.

Расширение:

- интегрировано в архитектуру VS Code через стандартный механизм расширений,
- использует внешние инструменты (`clang-tidy`, `clang-format`) как движок
  анализа и форматирования,
- предоставляет две независимые команды:
  - массовая правка стиля во всём workspace без переименований,
  - точечная правка текущего файла с безопасными переименованиями через
    Rename Symbol,
- учитывает требования к табуляции и скобкам вокруг коротких операторов,
- документировано в README и сопровождающих конфигурационных файлах,
- размещено в открытом репозитории GitHub.

Полученный плагин может использоваться не только для учебных целей,
но и как реальный инструмент автоматизации оформления C/C++‑кода в повседневной работе.
